<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>3D ASCII Human Anatomy Generator</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #00ff41; /* Matrix Green */
            --highlight-color: #fff;
            --ui-bg: rgba(0, 20, 0, 0.95);
            --border-color: #00aa2b;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-color);
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            user-select: none;
            touch-action: none; /* Prevent browser scrolling */
        }

        /* --- LAYOUT CONTAINERS --- */

        #ascii-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            white-space: pre;
            overflow: hidden;
            font-size: 8px; /* Slightly smaller for mobile density */
            line-height: 8px;
            pointer-events: none;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1;
        }

        @media (min-width: 768px) {
            #ascii-container {
                font-size: 10px;
                line-height: 10px;
            }
        }

        #interaction-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 10;
        }

        /* --- UI COMPONENTS --- */

        .ui-panel {
            background: var(--ui-bg);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            backdrop-filter: blur(2px);
        }

        button.toggle-btn, .tool-btn, #export-btn {
            background: rgba(0, 50, 0, 0.5);
            border: 1px solid var(--text-color);
            color: var(--text-color);
            cursor: pointer;
            font-family: inherit;
            transition: all 0.15s;
            text-transform: uppercase;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        button.toggle-btn:active, .tool-btn:active, #export-btn:active {
            background: var(--text-color);
            color: black;
        }

        button.toggle-btn.active {
            background: var(--text-color);
            color: black;
            box-shadow: 0 0 10px var(--text-color);
        }

        /* --- TOP HEADER (Responsive) --- */
        #header-controls {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            z-index: 30;
            padding: 10px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            pointer-events: none; /* Let clicks pass through gaps */
        }

        .header-group {
            pointer-events: auto;
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        #title-block {
            padding: 5px 10px;
            margin-bottom: 5px;
        }

        #title-block h1 {
            margin: 0;
            font-size: 14px;
            text-shadow: 0 0 5px var(--text-color);
            border: none;
        }

        .btn-row {
            display: flex;
            gap: 5px;
        }

        .btn-row button {
            padding: 8px 12px;
            font-size: 12px;
            min-height: 36px; /* Touch target size */
        }

        /* Female Controls specialized */
        #female-controls {
            display: flex;
            align-items: center;
            gap: 5px;
            background: rgba(0,20,0,0.8);
            padding: 5px;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            margin-top: 5px;
            pointer-events: auto;
        }

        /* --- SIDEBAR (Drawer Style on Mobile) --- */
        #sidebar {
            position: absolute;
            top: 60px;
            right: 0;
            bottom: 80px; /* Space for bottom bar */
            width: 260px;
            z-index: 25;
            background: rgba(0, 15, 0, 0.98);
            border-left: 1px solid var(--text-color);
            transform: translateX(110%);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            flex-direction: column;
            padding: 10px;
        }

        #sidebar.open {
            transform: translateX(0);
            box-shadow: -5px 0 20px rgba(0,0,0,0.5);
        }

        .sidebar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
            border-bottom: 1px dashed var(--text-color);
            padding-bottom: 5px;
        }

        #tree-root {
            overflow-y: auto;
            flex: 1;
            padding-right: 5px;
        }

        /* --- BOTTOM TOOLBAR (Mobile Dock) --- */
        #bottom-toolbar {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 60px;
            background: var(--bg-color);
            border-top: 1px solid var(--text-color);
            z-index: 30;
            display: flex;
            justify-content: space-around;
            align-items: center;
            padding: 0 10px;
        }

        .toolbar-group {
            display: flex;
            gap: 10px;
        }

        .icon-btn {
            width: 44px;
            height: 44px;
            border-radius: 50%;
            font-size: 20px;
            background: transparent;
            border: 1px solid var(--text-color);
            color: var(--text-color);
        }

        /* Visual Pad (Hidden by default on mobile, toggled) */
        #d-pad-overlay {
            position: absolute;
            bottom: 70px;
            left: 20px;
            z-index: 29;
            display: none; /* Toggled by button */
        }
        
        /* On desktop, we might want the D-pad always visible or styled differently, 
           but for this hybrid design, we'll keep it as a pop-up tool or persistent on desktop. */
        @media (min-width: 768px) {
            #d-pad-overlay {
                display: block !important;
            }
            #bottom-toolbar {
                display: none; /* Hide mobile toolbar on desktop */
            }
            #export-desktop {
                display: block;
            }
        }

        /* --- VISUAL TOOLS (Redesigned) --- */
        .pad-container {
            background: var(--ui-bg);
            border: 1px solid var(--text-color);
            padding: 10px;
            border-radius: 8px;
            display: grid;
            grid-template-columns: repeat(3, 30px);
            gap: 5px;
            justify-content: center;
        }

        .pad-btn {
            width: 30px;
            height: 30px;
            padding: 0;
            font-size: 14px;
        }

        /* --- DETAILS PANEL (Bottom Sheet style) --- */
        #details-panel {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            background: rgba(0, 10, 0, 0.98);
            border-top: 2px solid var(--text-color);
            padding: 20px;
            z-index: 50;
            transform: translateY(110%);
            transition: transform 0.3s ease-out;
            text-align: center;
            display: flex; /* Flex to handle visibility via transform */
            flex-direction: column;
            align-items: center;
        }

        #details-panel.visible {
            transform: translateY(0);
        }

        #detail-title {
            font-size: 1.2em;
            color: var(--highlight-color);
            margin: 0 0 5px 0;
        }

        #detail-desc {
            max-width: 600px;
            margin: 10px 0 20px 0;
            font-size: 0.9em;
        }

        .close-btn {
            position: absolute;
            top: 10px;
            right: 10px;
            border: none;
            background: none;
            color: var(--text-color);
            font-size: 20px;
            padding: 10px;
        }

        /* --- MISC --- */
        .label {
            position: absolute;
            background: rgba(0, 0, 0, 0.6);
            padding: 4px 8px;
            border: 1px solid var(--text-color);
            font-size: 10px; /* Larger for touch */
            pointer-events: auto;
            cursor: pointer;
            transform: translate(-50%, -50%);
            z-index: 15;
            white-space: nowrap;
        }

        #export-desktop {
            position: absolute;
            bottom: 20px;
            right: 20px;
            z-index: 20;
            display: none; /* Shown on desktop via media query */
            padding: 10px 20px;
        }

        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
            background: black;
            padding: 20px;
            border: 2px solid var(--text-color);
        }

        /* Tree View Items */
        .tree-toggle { padding: 8px 0; font-size: 14px; }
        .part-item { padding: 8px 10px; font-size: 13px; border-bottom: 1px solid rgba(0,255,0,0.1); }

    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="loading" class="loading">INITIALIZING...</div>

    <div id="ascii-container"></div>
    <div id="interaction-overlay"></div>

    <!-- HEADER CONTROLS (Top Left/Right) -->
    <div id="header-controls">
        <div class="header-group">
            <div id="title-block" class="ui-panel">
                <h1>ANATOMY GEN v2.3</h1>
            </div>
            <div class="btn-row">
                <button class="toggle-btn active" id="btn-male" onclick="switchGender('male')">MALE</button>
                <button class="toggle-btn" id="btn-female" onclick="switchGender('female')">FEMALE</button>
            </div>
            <!-- Female Options -->
            <div id="female-controls" style="display:none;">
                <span style="font-size: 10px;">BUST:</span>
                <button class="toggle-btn" style="width:30px; height:30px;" onclick="adjustBreastSize(0.1)">+</button>
                <button class="toggle-btn" style="width:30px; height:30px;" onclick="adjustBreastSize(-0.1)">-</button>
            </div>
        </div>

        <div class="header-group">
            <button class="toggle-btn" id="btn-tree" onclick="toggleSidebar()">
                <span style="font-size:18px;">‚ò∞</span>
            </button>
        </div>
    </div>

    <!-- SIDEBAR DRAWER -->
    <div id="sidebar" class="ui-panel">
        <div class="sidebar-header">
            <h3>ANATOMY INDEX</h3>
            <button class="toggle-btn" onclick="toggleSidebar()">‚úï</button>
        </div>
        <ul id="tree-root" class="tree-root"></ul>
    </div>

    <!-- DESKTOP VISUAL CONTROLS / MOBILE POPUP -->
    <div id="d-pad-overlay">
        <!-- Pan Controls -->
        <div class="pad-container" style="margin-bottom: 10px;">
            <div style="grid-column: 1/-1; text-align:center; font-size:10px; margin-bottom:5px;">PAN</div>
            <div></div>
            <button class="tool-btn pad-btn" onclick="panCamera(0, 1)">‚Üë</button>
            <div></div>
            <button class="tool-btn pad-btn" onclick="panCamera(-1, 0)">‚Üê</button>
            <button class="tool-btn pad-btn" onclick="resetCamera()" style="font-size:9px;">RST</button>
            <button class="tool-btn pad-btn" onclick="panCamera(1, 0)">‚Üí</button>
            <div></div>
            <button class="tool-btn pad-btn" onclick="panCamera(0, -1)">‚Üì</button>
            <div></div>
        </div>
        
        <!-- Rotate Controls -->
        <div class="pad-container">
            <div style="grid-column: 1/-1; text-align:center; font-size:10px; margin-bottom:5px;">ROTATE</div>
            <div></div>
            <button class="tool-btn pad-btn" onclick="rotateCamera(0, -0.1)">‚ñ≤</button>
            <div></div>
            <button class="tool-btn pad-btn" onclick="rotateCamera(0.1, 0)">‚Ü∫</button>
            <button class="tool-btn pad-btn" onclick="rotateCamera(-0.1, 0)">‚Üª</button>
            <div></div>
            <button class="tool-btn pad-btn" onclick="rotateCamera(0, 0.1)">‚ñº</button>
            <div></div>
        </div>
    </div>

    <!-- BOTTOM MOBILE TOOLBAR -->
    <div id="bottom-toolbar">
        <button class="icon-btn" onclick="toggleLabelsMobile()" id="mobile-lbl-btn">üè∑Ô∏è</button>
        <button class="icon-btn" onclick="toggleDPad()" id="mobile-dpad-btn">üéÆ</button>
        <button class="icon-btn" onclick="resetCamera()">‚ü≤</button>
        <button class="icon-btn" onclick="exportToTxt()">üíæ</button>
    </div>

    <!-- Desktop Export Button -->
    <button id="export-desktop" class="toggle-btn" onclick="exportToTxt()">EXPORT .TXT</button>

    <!-- DETAILS SHEET -->
    <div id="details-panel">
        <button class="close-btn" onclick="closeDetails()">‚úï</button>
        <h2 id="detail-title">PART NAME</h2>
        <h3 id="detail-cat" style="color: #666; font-size: 0.8em; text-transform:uppercase;">CATEGORY</h3>
        <p id="detail-desc">Description text.</p>
        <button class="toggle-btn" style="padding: 10px 30px;" onclick="closeDetails()">RETURN TO VIEW</button>
    </div>

    <!-- LABELS -->
    <div id="labels-container"></div>

<script>
/**
 * 3D ASCII ANATOMY GENERATOR v2.1 - REALISM UPDATE
 */

// --- CONFIGURATION ---
const CHAR_SET = " .:-=+*#%@";
let currentGender = 'male';
let showLabels = true;
let breastScale = 1.0;

// --- THREE.JS SETUP ---
const scene = new THREE.Scene();
const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ antialias: false });
renderer.setSize(100, 100); // Low res for ASCII processing

// --- STATE ---
let bodyGroup;
let parts = [];
let labels = [];
let isZoomed = false;

// Camera System
let currentLookAt = new THREE.Vector3(0, 0, 0);
let targetLookAt = new THREE.Vector3(0, 0, 0);
let targetCamPos = new THREE.Vector3();

let camRadius = 25;
let camTheta = 0;
let camPhi = Math.PI / 2;

// Input State
let isDragging = false;
let lastMouseX = 0, lastMouseY = 0;
let lastTouchDist = 0;

// --- INITIALIZATION ---
function init() {
    // Lights
    const ambientLight = new THREE.AmbientLight(0x444444);
    scene.add(ambientLight);
    const dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
    dirLight.position.set(10, 10, 10);
    scene.add(dirLight);
    const backLight = new THREE.DirectionalLight(0x888888, 0.5);
    backLight.position.set(-10, 5, -10);
    scene.add(backLight);

    updateCameraPosition();
    createHumanModel('male');

    // Input Listeners
    const overlay = document.getElementById('interaction-overlay');
    
    // Mouse
    overlay.addEventListener('mousedown', onMouseDown);
    window.addEventListener('mousemove', onMouseMove);
    window.addEventListener('mouseup', onMouseUp);
    overlay.addEventListener('wheel', onWheel, { passive: false }); // Non-passive for preventDefault

    // Touch
    overlay.addEventListener('touchstart', onTouchStart, { passive: false });
    overlay.addEventListener('touchmove', onTouchMove, { passive: false });
    overlay.addEventListener('touchend', onTouchEnd);

    window.addEventListener('resize', onResize);
    document.getElementById('loading').style.display = 'none';

    animate();
}

// --- ANATOMY GENERATION (REALISM UPDATE) ---
function createHumanModel(gender) {
    if (bodyGroup) scene.remove(bodyGroup);
    
    const labelCont = document.getElementById('labels-container');
    labelCont.innerHTML = '';
    parts = [];
    labels = [];

    bodyGroup = new THREE.Group();
    const mat = new THREE.MeshPhongMaterial({ color: 0xffffff, flatShading: true });
    
    function addPart(geom, x, y, z, name, desc, category) {
        const mesh = new THREE.Mesh(geom, mat);
        mesh.position.set(x, y, z);
        mesh.name = name;
        mesh.userData = { description: desc, category: category };
        bodyGroup.add(mesh);
        parts.push(mesh);
        createLabel(mesh);
        return mesh;
    }

    const isMale = gender === 'male';
    
    // Proportions
    // Male: Broader shoulders, V-taper. Female: Wider hips, Hourglass.
    const shoulderWidth = isMale ? 2.6 : 2.0;
    const hipWidth = isMale ? 1.6 : 2.3;
    const waistWidth = isMale ? 1.5 : 1.3;
    
    // 1. HEAD & NECK
    // Skull - elongated slightly
    const skullGeo = new THREE.SphereGeometry(0.95, 10, 10);
    skullGeo.scale(0.85, 1, 0.9);
    addPart(skullGeo, 0, 7.8, 0, "Cranium", "Skull protecting the brain.", "Head & Neck");
    
    // Jaw (Mandible) - distinct shape
    addPart(new THREE.BoxGeometry(1.0, 0.5, 0.8), 0, 7.2, 0.1, "Mandible", "Jaw bone.", "Head & Neck");

    // --- FACIAL FEATURES ---
    
    // Eyes
    addPart(new THREE.SphereGeometry(0.12), -0.35, 7.9, 0.75, "Right Eye", "Vision.", "Head & Neck");
    addPart(new THREE.SphereGeometry(0.12), 0.35, 7.9, 0.75, "Left Eye", "Vision.", "Head & Neck");

    // Eyebrows
    const browGeo = new THREE.BoxGeometry(0.35, 0.05, 0.1);
    const lBrow = addPart(browGeo, 0.35, 8.15, 0.85, "Left Eyebrow", "Facial hair.", "Head & Neck");
    lBrow.rotation.z = 0.1;
    const rBrow = addPart(browGeo, -0.35, 8.15, 0.85, "Right Eyebrow", "Facial hair.", "Head & Neck");
    rBrow.rotation.z = -0.1;

    // Nose (Pyramid shape)
    const noseGeo = new THREE.ConeGeometry(0.12, 0.4, 4);
    // Rotate cone to point forward
    const nose = addPart(noseGeo, 0, 7.75, 1.0, "Nose", "Olfactory organ.", "Head & Neck");
    nose.rotation.x = -Math.PI / 2; // Point outward
    nose.rotation.y = Math.PI / 4;  // Rotate so flat side isn't up

    // Mouth / Lips
    const mouthGeo = new THREE.BoxGeometry(0.4, 0.1, 0.1);
    addPart(mouthGeo, 0, 7.45, 0.95, "Mouth", "Oral cavity opening.", "Head & Neck");

    // Ears
    const earGeo = new THREE.BoxGeometry(0.2, 0.5, 0.3);
    addPart(earGeo, 0.95, 7.8, 0, "Left Ear", "Auditory organ.", "Head & Neck");
    addPart(earGeo, -0.95, 7.8, 0, "Right Ear", "Auditory organ.", "Head & Neck");


    // Neck
    addPart(new THREE.CylinderGeometry(0.45, 0.5, 1.2, 8), 0, 6.4, -0.1, "Neck", "Cervical Spine.", "Head & Neck");

    // HAIR
    const hairMat = new THREE.MeshPhongMaterial({ color: 0x888888, flatShading: true });
    
    if (isMale) {
        // Male Hair - Short, styled
        const hairGeo = new THREE.SphereGeometry(1.0, 12, 12);
        hairGeo.scale(0.9, 0.6, 0.95);
        const hair = new THREE.Mesh(hairGeo, hairMat);
        hair.position.set(0, 8.5, 0.05);
        hair.name = "Hair";
        hair.userData = { description: "Short, styled hair.", category: "Head & Neck" };
        bodyGroup.add(hair);
        parts.push(hair);
        createLabel(hair);
    } else {
        // Female Hair - Longer with a bun
        // Top part
        const hairTopGeo = new THREE.SphereGeometry(1.0, 12, 12);
        hairTopGeo.scale(0.95, 0.7, 1.0);
        const hairTop = new THREE.Mesh(hairTopGeo, hairMat);
        hairTop.position.set(0, 8.4, 0);
        hairTop.name = "Hair (Top)";
        hairTop.userData = { description: "Styled hair.", category: "Head & Neck" };
        bodyGroup.add(hairTop);
        parts.push(hairTop);
        createLabel(hairTop);

        // Bun at the back
        const bunGeo = new THREE.SphereGeometry(0.6, 10, 10);
        bunGeo.scale(1, 0.8, 1);
        const bun = new THREE.Mesh(bunGeo, hairMat);
        bun.position.set(0, 8.0, -0.9);
        bun.name = "Hair (Bun)";
        bun.userData = { description: "Hair bun.", category: "Head & Neck" };
        bodyGroup.add(bun);
        parts.push(bun);
        createLabel(bun);
    }

    // 2. TORSO
    // Clavicles
    const clav = addPart(new THREE.CylinderGeometry(0.12, 0.12, shoulderWidth * 1.2, 6), 0, 6.0, 0.2, "Clavicles", "Collarbones.", "Torso");
    clav.rotation.z = Math.PI / 2;

    // Ribcage (Thorax) - Tapered cylinder instead of box
    // Top width matches shoulders roughly, bottom matches waist
    const chestTop = shoulderWidth * 0.45; 
    const chestBot = waistWidth * 0.6; 
    const chestGeo = new THREE.CylinderGeometry(chestTop, chestBot, 2.5, 10);
    chestGeo.scale(1, 1, 0.7); // Flatten slightly front-to-back
    addPart(chestGeo, 0, 4.8, 0, "Thorax", "Ribcage containing heart/lungs.", "Torso");

    // --- ATHLETIC ABDOMEN GENERATION ---
    
    // 1. Core Volume (The visceral cavity behind the muscles)
    const coreTop = chestBot * 0.85;
    const coreBot = waistWidth * 0.7;
    const absHeight = 2.0;
    // Base cylinder slightly recessed
    const coreGeo = new THREE.CylinderGeometry(coreTop, coreBot, absHeight, 8);
    coreGeo.scale(1, 1, 0.65); 
    addPart(coreGeo, 0, 2.7, -0.15, "Core", "Abdominal cavity.", "Abdomen");

    // 2. Rectus Abdominis (The "Six Pack")
    const rows = 3;
    const startY = 3.55; // Just below sternum
    const muscleH = absHeight / 3.4;
    
    for(let r=0; r<rows; r++) {
        // Taper width slightly as we go down to waist
        const rowTaper = 1.0 - (r * 0.12); 
        const yPos = startY - (r * (muscleH + 0.05));
        
        // Z-offset follows the curve of the spine (upper is further out, lower is in)
        const zPos = 0.42 - (r * 0.04); 

        [-1, 1].forEach(side => {
            const sideName = side === 1 ? "Left" : "Right";
            const xPos = side * (isMale ? 0.30 : 0.22) * rowTaper;

            let muscGeo;
            
            if (isMale) {
                // Male: Boxy, sharp cuts, higher relief
                const w = 0.55 * rowTaper;
                const h = muscleH * 0.92;
                const d = 0.22; // Deep definition
                muscGeo = new THREE.BoxGeometry(w, h, d);
                
            } else {
                // Female: "11-line abs" - smoother, flatter, vertical definition
                const w = 0.45 * rowTaper;
                const h = muscleH * 0.95;
                const d = 0.15; // Softer definition
                muscGeo = new THREE.SphereGeometry(1, 8, 8); 
                muscGeo.scale(w * 0.5, h * 0.5, d); // Flattened oval
            }

            const absMesh = addPart(muscGeo, xPos, yPos, zPos, 
                `${sideName} Abs (Row ${r+1})`, 
                "Rectus Abdominis segment.", "Abdomen");
            
            // Rotations to conform to torso curve
            absMesh.rotation.x = 0.1; // Tilt back 
            absMesh.rotation.y = side * -0.05; // Slight wrap
            absMesh.rotation.z = side * -0.02; // Fan
        });
    }

    // 3. Obliques (Side framing)
    // Tapered cylinders on the flanks to create the V-taper
    const oblHeight = 1.9;
    const oblGeo = new THREE.CylinderGeometry(0.35, 0.45, oblHeight, 6);
    oblGeo.scale(1, 1, 0.6); // Flatten against side
    
    [-1, 1].forEach(side => {
        const xPos = side * (waistWidth * 0.6);
        const obl = addPart(oblGeo, xPos, 2.7, 0.05, 
            `${side === 1 ? 'Left' : 'Right'} Oblique`, 
            "External Oblique muscle.", "Abdomen");
        obl.rotation.z = side * 0.15; // Flare out at hips
        obl.rotation.y = side * 0.1;
    });

    // Pelvis - Distinct Shape
    // Female pelvis is wider at bottom (hips)
    const pelvisTop = waistWidth * 0.5;
    const pelvisBot = hipWidth * 0.5;
    const pelvisGeo = new THREE.CylinderGeometry(pelvisTop, pelvisBot, 1.5, 8);
    pelvisGeo.scale(1, 1, 0.8);
    addPart(pelvisGeo, 0, 1.1, 0, "Pelvis", "Hip bone structure.", "Torso");

    // Gender Specifics
    if (!isMale) {
        // --- CUSTOM TEARDROP GEOMETRY GENERATOR ---
        const bSize = 0.6 * breastScale;
        const zOff = 0.55 + bSize * 0.2; 

        // Function to mold a sphere into a teardrop
        function createTeardrop(radius) {
            // Start with a higher res sphere for smooth deformation
            const geo = new THREE.SphereGeometry(radius, 16, 12);
            const pos = geo.attributes.position;
            const v = new THREE.Vector3();

            for (let i = 0; i < pos.count; i++) {
                v.fromBufferAttribute(pos, i);

                // 1. Taper the top half (y > 0) to create the slope
                if (v.y > 0) {
                    // The higher the vertex, the more we pull x/z in
                    const taperFactor = 1.0 - (v.y / radius) * 0.55; 
                    v.x *= taperFactor;
                    v.z *= taperFactor;
                }

                // 2. Flatten the back (z < 0) to sit against chest
                // We assume local Z- is the back
                if (v.z < 0) {
                    v.z *= 0.6; 
                }
                
                // 3. Slightly expand bottom (y < 0) for fullness (gravity)
                if (v.y < 0) {
                    const swellFactor = 1.0 + Math.abs(v.y / radius) * 0.1;
                    v.z *= swellFactor;
                }

                pos.setXYZ(i, v.x, v.y, v.z);
            }
            
            geo.computeVertexNormals(); // Fix lighting after deformation
            
            // Final squash to make it organic (not too pointy)
            geo.scale(1.0, 1.1, 0.8); 
            
            return geo;
        }

        // Generate geometry
        // We create two separate instances so they can be rotated independently if needed, 
        // though we could clone.
        const lGeo = createTeardrop(bSize);
        const rGeo = createTeardrop(bSize);

        // Positioning
        // y: 4.5 is roughly mid-chest. 
        // zOff: Depth offset.
        const lBreast = addPart(lGeo, 0.55, 4.45, zOff, "Left Breast", "Mammary gland (Teardrop profile).", "Torso");
        const rBreast = addPart(rGeo, -0.55, 4.45, zOff, "Right Breast", "Mammary gland (Teardrop profile).", "Torso");

        // Orientation
        // Rotate outward (Y) and slightly down (X) for natural hang
        lBreast.rotation.y = -0.2; 
        lBreast.rotation.x = 0.1; // Tilt bottom out/top in slightly if needed, or leave 0 depending on vertex logic.
        // Actually, with the taper logic, Y+ is the top slope. We want Y+ pointing slightly back towards clavicle.
        lBreast.rotation.x = -0.15; 

        rBreast.rotation.y = 0.2;
        rBreast.rotation.x = -0.15;

    } else {
        // Pectorals (Male)
        addPart(new THREE.BoxGeometry(1.0, 0.8, 0.3), 0.6, 5.0, 0.6, "Right Pec", "Pectoralis Major.", "Torso");
        addPart(new THREE.BoxGeometry(1.0, 0.8, 0.3), -0.6, 5.0, 0.6, "Left Pec", "Pectoralis Major.", "Torso");
    }

    // INTERNAL ORGANS (Stylized external representation for interaction)
    addPart(new THREE.SphereGeometry(0.55), -0.5, 2.9, 0.3, "Stomach", "Digestion.", "Abdomen");
    addPart(new THREE.BoxGeometry(1.0, 0.8, 0.6), 0.5, 3.0, 0.3, "Liver", "Detox.", "Abdomen");
    addPart(new THREE.SphereGeometry(0.7), 0, 2.2, 0.4, "Intestines", "Absorption.", "Abdomen");

    // 3. ARMS
    const armLen = 2.8;
    [1, -1].forEach(s => {
        const side = s === 1 ? "Right" : "Left";
        const cat = s === 1 ? "Right Arm" : "Left Arm";
        
        // Shoulder (Deltoid) - Sphere to smooth joint
        const deltSize = isMale ? 0.75 : 0.6;
        addPart(new THREE.SphereGeometry(deltSize, 8, 8), s * (shoulderWidth/2 + 0.2), 5.6, 0, `${side} Deltoid`, "Shoulder muscle.", cat);

        // Upper Arm (Humerus/Bicep) - Tapered cylinder
        const uArmThick = isMale ? 0.45 : 0.35;
        const uArmGeo = new THREE.CylinderGeometry(uArmThick, uArmThick*0.8, armLen, 6);
        addPart(uArmGeo, s * (shoulderWidth/2 + 0.4), 3.8, 0, `${side} Arm`, "Humerus/Biceps.", cat);

        // Elbow
        addPart(new THREE.SphereGeometry(uArmThick*0.9), s * (shoulderWidth/2 + 0.5), 2.3, -0.1, `${side} Elbow`, "Joint.", cat);

        // Forearm
        const fArmGeo = new THREE.CylinderGeometry(uArmThick*0.9, uArmThick*0.6, armLen*0.9, 6);
        addPart(fArmGeo, s * (shoulderWidth/2 + 0.6), 0.9, 0.2, `${side} Forearm`, "Radius/Ulna.", cat);

        // Hand
        addPart(new THREE.BoxGeometry(0.5, 0.7, 0.3), s * (shoulderWidth/2 + 0.65), -0.8, 0.3, `${side} Hand`, "Hand.", cat);
    });

    // 4. LEGS
    const legLen = 4.0;
    // Females often have legs starting slightly wider due to pelvis width
    const legSpace = hipWidth * 0.3; 
    
    [1, -1].forEach(s => {
        const side = s === 1 ? "Right" : "Left";
        const cat = s === 1 ? "Right Leg" : "Left Leg";
        const lx = s * legSpace;
        
        // Hip Joint - smooths connection to pelvis
        addPart(new THREE.SphereGeometry(0.65), lx, 0.5, 0, `${side} Hip`, "Hip Joint.", "Torso");

        // Thigh (Femur/Quads) - Tapered (Thicker at top)
        const thighTop = isMale ? 0.65 : 0.7; 
        const thighBot = 0.5;
        const thighGeo = new THREE.CylinderGeometry(thighTop, thighBot, legLen, 8);
        addPart(thighGeo, lx, -1.8, 0, `${side} Thigh`, "Femur/Quadriceps.", cat);

        // Knee
        addPart(new THREE.SphereGeometry(0.52), lx, -4.0, 0.1, `${side} Knee`, "Patella.", cat);

        // Calf (Tibia) - Tapered (Thicker at top for muscle)
        const calfGeo = new THREE.CylinderGeometry(0.5, 0.35, legLen, 8);
        addPart(calfGeo, lx, -6.2, 0, `${side} Calf`, "Tibia/Gastrocnemius.", cat);

        // Ankle
        addPart(new THREE.SphereGeometry(0.38), lx, -8.3, 0.1, `${side} Ankle`, "Joint.", cat);

        // Foot
        addPart(new THREE.BoxGeometry(0.6, 0.5, 1.7), lx, -8.7, 0.6, `${side} Foot`, "Foot.", cat);
    });

    scene.add(bodyGroup);
    populateSidebar();
}

function createLabel(mesh) {
    const div = document.createElement('div');
    div.className = 'label';
    div.innerText = mesh.name;
    div.onclick = (e) => {
        e.stopPropagation(); // Stop propagation immediately
        e.preventDefault();  // Prevent ghost clicks on touch
        focusOnPart(mesh);
    };
    // Touch event specifically for labels to ensure responsiveness
    div.ontouchend = (e) => {
        e.stopPropagation();
        e.preventDefault();
        focusOnPart(mesh);
    }
    document.getElementById('labels-container').appendChild(div);
    labels.push({ element: div, mesh: mesh });
}

// --- INPUT HANDLING ---

function onMouseDown(e) {
    isDragging = true;
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
}

function onMouseMove(e) {
    if (!isDragging || isZoomed) return;
    const deltaX = e.clientX - lastMouseX;
    const deltaY = e.clientY - lastMouseY;
    
    rotateCamera(deltaX * 0.005, deltaY * 0.005);
    
    lastMouseX = e.clientX;
    lastMouseY = e.clientY;
}

function onMouseUp() { isDragging = false; }

function onWheel(e) {
    e.preventDefault();
    zoomCamera(e.deltaY * 0.05);
}

// Touch Handling
function onTouchStart(e) {
    if (e.touches.length === 1) {
        isDragging = true;
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        isDragging = false;
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        lastTouchDist = Math.sqrt(dx * dx + dy * dy);
    }
}

function onTouchMove(e) {
    e.preventDefault(); // Stop scrolling
    if (isZoomed) return;

    if (e.touches.length === 1 && isDragging) {
        const deltaX = e.touches[0].clientX - lastMouseX;
        const deltaY = e.touches[0].clientY - lastMouseY;
        rotateCamera(deltaX * 0.005, deltaY * 0.005);
        lastMouseX = e.touches[0].clientX;
        lastMouseY = e.touches[0].clientY;
    } else if (e.touches.length === 2) {
        const dx = e.touches[0].clientX - e.touches[1].clientX;
        const dy = e.touches[0].clientY - e.touches[1].clientY;
        const dist = Math.sqrt(dx * dx + dy * dy);
        
        const delta = lastTouchDist - dist;
        zoomCamera(delta * 0.1);
        lastTouchDist = dist;
    }
}

function onTouchEnd() {
    isDragging = false;
}

// --- CAMERA LOGIC ---

function rotateCamera(dx, dy) {
    if (isZoomed) return;
    camTheta -= dx; // Invert X for natural feel
    camPhi -= dy;
    camPhi = Math.max(0.1, Math.min(Math.PI - 0.1, camPhi));
    updateCameraPosition();
}

function panCamera(dx, dy) {
    if (isZoomed) return;
    const forward = new THREE.Vector3();
    camera.getWorldDirection(forward);
    const right = new THREE.Vector3().crossVectors(forward, camera.up).normalize();
    const up = new THREE.Vector3().crossVectors(right, forward).normalize();
    
    currentLookAt.addScaledVector(right, dx * 2);
    currentLookAt.addScaledVector(up, dy * 2);
    updateCameraPosition();
}

function zoomCamera(delta) {
    if (isZoomed) return;
    camRadius += delta;
    camRadius = Math.max(5, Math.min(60, camRadius));
    updateCameraPosition();
}

function resetCamera() {
    camRadius = 25;
    camTheta = 0;
    camPhi = Math.PI / 2;
    currentLookAt.set(0,0,0);
    closeDetails();
}

function updateCameraPosition() {
    if (isZoomed) return;
    const rx = camRadius * Math.sin(camPhi) * Math.sin(camTheta);
    const ry = camRadius * Math.cos(camPhi);
    const rz = camRadius * Math.sin(camPhi) * Math.cos(camTheta);
    camera.position.set(currentLookAt.x + rx, currentLookAt.y + ry, currentLookAt.z + rz);
    camera.lookAt(currentLookAt);
}

// --- UI LOGIC ---

function focusOnPart(mesh) {
    isZoomed = true;
    const worldPos = new THREE.Vector3();
    mesh.getWorldPosition(worldPos);
    targetLookAt.copy(worldPos);
    
    const dir = new THREE.Vector3().subVectors(camera.position, currentLookAt).normalize();
    targetCamPos.copy(worldPos).add(dir.multiplyScalar(8)); // Slightly closer

    // Show Details Panel (Bottom Sheet)
    const panel = document.getElementById('details-panel');
    document.getElementById('detail-title').innerText = mesh.name;
    document.getElementById('detail-cat').innerText = mesh.userData.category;
    document.getElementById('detail-desc').innerText = mesh.userData.description;
    panel.classList.add('visible');
    
    // Close sidebar if open
    document.getElementById('sidebar').classList.remove('open');
}

function closeDetails() {
    isZoomed = false;
    currentLookAt.copy(targetLookAt);
    const offset = new THREE.Vector3().subVectors(camera.position, currentLookAt);
    camRadius = Math.max(15, offset.length()); // Ensure we don't snap too close
    updateCameraPosition();
    document.getElementById('details-panel').classList.remove('visible');
}

function toggleSidebar() {
    document.getElementById('sidebar').classList.toggle('open');
}

function toggleDPad() {
    const dpad = document.getElementById('d-pad-overlay');
    dpad.style.display = (dpad.style.display === 'block') ? 'none' : 'block';
}

function toggleLabelsMobile() {
    showLabels = !showLabels;
    document.getElementById('labels-container').style.display = showLabels ? 'block' : 'none';
    const btn = document.getElementById('mobile-lbl-btn');
    btn.style.background = showLabels ? 'var(--text-color)' : 'transparent';
    btn.style.color = showLabels ? 'black' : 'var(--text-color)';
}

function populateSidebar() {
    const root = document.getElementById('tree-root');
    root.innerHTML = '';
    const categories = {};
    parts.forEach(p => {
        const c = p.userData.category || "Other";
        if(!categories[c]) categories[c] = [];
        categories[c].push(p);
    });
    
    Object.keys(categories).forEach(cat => {
        const li = document.createElement('li');
        const toggle = document.createElement('div');
        toggle.className = 'tree-toggle';
        toggle.innerText = `[+] ${cat}`;
        
        const children = document.createElement('div');
        children.style.display = 'none';
        children.style.paddingLeft = '15px';
        
        toggle.onclick = () => {
            const isOpen = children.style.display === 'block';
            children.style.display = isOpen ? 'none' : 'block';
            toggle.innerText = isOpen ? `[+] ${cat}` : `[-] ${cat}`;
        };
        
        categories[cat].forEach(mesh => {
            const item = document.createElement('div');
            item.className = 'part-item';
            item.innerText = mesh.name;
            item.onclick = () => focusOnPart(mesh);
            children.appendChild(item);
        });
        
        li.appendChild(toggle);
        li.appendChild(children);
        root.appendChild(li);
    });
}

function switchGender(g) {
    if(currentGender === g) return;
    currentGender = g;
    document.getElementById('btn-male').classList.toggle('active', g === 'male');
    document.getElementById('btn-female').classList.toggle('active', g === 'female');
    document.getElementById('female-controls').style.display = (g === 'female') ? 'flex' : 'none';
    createHumanModel(g);
}

function adjustBreastSize(d) {
    breastScale = Math.max(0.5, Math.min(3.0, breastScale + d));
    createHumanModel(currentGender);
}

function exportToTxt() {
    const content = document.getElementById('ascii-container').innerText;
    const blob = new Blob([content], {type: "text/plain;charset=utf-8"});
    const a = document.createElement("a");
    a.href = URL.createObjectURL(blob);
    a.download = `anatomy_${Date.now()}.txt`;
    a.click();
}

function renderASCII() {
    // 1. Determine density based on screen
    const factor = window.innerWidth < 768 ? 6 : 8; // Lower res on mobile for speed/readability
    const w = Math.floor(window.innerWidth / factor);
    const h = Math.floor(window.innerHeight / (factor * 1.8)); // Adjust for char aspect
    
    if (renderer.domElement.width !== w || renderer.domElement.height !== h) {
        renderer.setSize(w, h);
    }
    
    renderer.render(scene, camera);
    const gl = renderer.getContext();
    const pixels = new Uint8Array(w * h * 4);
    gl.readPixels(0,0,w,h,gl.RGBA,gl.UNSIGNED_BYTE,pixels);
    
    let str = "";
    for(let y=h-1; y>=0; y--) {
        for(let x=0; x<w; x++) {
            const i = (y*w + x)*4;
            if(pixels[i+3]===0) { str += " "; continue; }
            const b = (pixels[i]*0.3 + pixels[i+1]*0.59 + pixels[i+2]*0.11)/255;
            str += CHAR_SET[Math.floor(b*(CHAR_SET.length-1))];
        }
        str += "\n";
    }
    document.getElementById('ascii-container').innerText = str;
}

function updateLabels() {
    if(!showLabels) return;
    labels.forEach(l => {
        if(isZoomed && l.mesh.name !== document.getElementById('detail-title').innerText) {
            l.element.style.display = 'none'; return;
        }
        const pos = l.mesh.position.clone();
        pos.applyMatrix4(l.mesh.parent.matrixWorld);
        pos.project(camera);
        
        if(pos.z > 1 || Math.abs(pos.x)>1 || Math.abs(pos.y)>1) {
            l.element.style.display = 'none';
        } else {
            l.element.style.display = 'block';
            l.element.style.left = (pos.x * 0.5 + 0.5) * window.innerWidth + 'px';
            l.element.style.top = (-(pos.y * 0.5) + 0.5) * window.innerHeight + 'px';
        }
    });
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
}

function animate() {
    requestAnimationFrame(animate);
    if(isZoomed) {
        camera.position.lerp(targetCamPos, 0.05);
        const temp = currentLookAt.clone().lerp(targetLookAt, 0.05);
        camera.lookAt(temp);
    }
    renderASCII();
    updateLabels();
}

init();

</script>
</body>
</html>
